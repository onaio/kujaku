<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MBTilesHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kujaku</a> &gt; <a href="index.source.html" class="el_package">io.ona.kujaku.mbtiles</a> &gt; <span class="el_source">MBTilesHelper.java</span></div><h1>MBTilesHelper.java</h1><pre class="source lang-java linenums">package io.ona.kujaku.mbtiles;

import android.content.Context;
import android.graphics.Color;
import android.os.Environment;
import android.support.annotation.NonNull;
import android.text.TextUtils;
import android.util.Pair;

import com.mapbox.mapboxsdk.maps.Style;
import com.mapbox.mapboxsdk.style.layers.FillLayer;
import com.mapbox.mapboxsdk.style.layers.Layer;
import com.mapbox.mapboxsdk.style.layers.LineLayer;
import com.mapbox.mapboxsdk.style.layers.RasterLayer;
import com.mapbox.mapboxsdk.style.sources.RasterSource;
import com.mapbox.mapboxsdk.style.sources.Source;
import com.mapbox.mapboxsdk.style.sources.TileSet;
import com.mapbox.mapboxsdk.style.sources.VectorSource;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import io.ona.kujaku.plugin.switcher.BaseLayerSwitcherPlugin;
import io.ona.kujaku.plugin.switcher.layer.MBTilesLayer;
import timber.log.Timber;

import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor;
import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity;
import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor;
import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineOpacity;
import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth;
import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.rasterOpacity;

/**
 * Created by samuelgithengi on 9/29/19.
 */
<span class="fc" id="L42">public class MBTilesHelper {</span>

    public static final String MB_TILES_EXTENSION = &quot;.mbtiles&quot;;

    public static final String MB_TILES_DIRECTORY = &quot;/mbtiles&quot;;

    protected TileHttpServer tileServer;

<span class="fc" id="L50">    private File mbtilesDir = new File(Environment.getExternalStorageDirectory().getPath() + MB_TILES_DIRECTORY);</span>

    private void init(List&lt;File&gt; offlineFiles) {
<span class="pc bpc" id="L53" title="2 of 4 branches missed.">        if (offlineFiles == null || offlineFiles.isEmpty()) {</span>
<span class="nc" id="L54">            return;</span>
<span class="pc bpc" id="L55" title="1 of 4 branches missed.">        } else if (tileServer == null || !tileServer.isStarted()) {</span>
<span class="fc" id="L56">            initializeMbTilesServer();</span>
        }
<span class="fc" id="L58">    }</span>

    public void initializeMbTileslayers(@NonNull Style style, List&lt;File&gt; offlineFiles) {
<span class="fc" id="L61">        init(offlineFiles);</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        for (File file : offlineFiles) {</span>
<span class="fc" id="L63">            String name = file.getName();</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">            if (name.endsWith(MB_TILES_EXTENSION)) {</span>
<span class="fc" id="L65">                String id = name.substring(0, name.length() - MB_TILES_EXTENSION.length());</span>
<span class="fc" id="L66">                addMbtiles(style, id, file);</span>
            }
<span class="fc" id="L68">        }</span>
<span class="fc" id="L69">    }</span>

    public Pair&lt;Set&lt;Source&gt;, Set&lt;Layer&gt;&gt; initializeMbTileslayers(File offlineFile) {
<span class="fc" id="L72">        init(Collections.singletonList(offlineFile));</span>
<span class="fc" id="L73">        Set&lt;Source&gt; sources = new HashSet&lt;&gt;();</span>
<span class="fc" id="L74">        Set&lt;Layer&gt; layers = new HashSet&lt;&gt;();</span>
<span class="fc" id="L75">        String name = offlineFile.getName();</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (name.endsWith(MB_TILES_EXTENSION)) {</span>
<span class="fc" id="L77">            String id = name.substring(0, name.length() - MB_TILES_EXTENSION.length());</span>
<span class="fc" id="L78">            Pair&lt;Source, List&lt;Layer&gt;&gt; sourceAndLayers = addMbtiles(id, offlineFile);</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">            if (sourceAndLayers != null) {</span>
<span class="fc" id="L80">                sources.add(sourceAndLayers.first);</span>
<span class="fc" id="L81">                layers.addAll(sourceAndLayers.second);</span>
            }
<span class="fc" id="L83">            return new Pair&lt;&gt;(sources, layers);</span>
        }
<span class="fc" id="L85">        return null;</span>
    }

    public void setMBTileLayers(Context context, BaseLayerSwitcherPlugin baseLayerSwitcherPlugin) {
<span class="pc bpc" id="L89" title="3 of 6 branches missed.">        if (mbtilesDir.exists() &amp;&amp; mbtilesDir.exists() &amp;&amp; mbtilesDir.listFiles() != null) {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            for (File mbTile : mbtilesDir.listFiles()) {</span>
<span class="fc" id="L91">                MBTilesLayer mbTilesLayer = new MBTilesLayer(context, mbTile, this);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">                if (!TextUtils.isEmpty(mbTilesLayer.getDisplayName())) {</span>
<span class="fc" id="L93">                    baseLayerSwitcherPlugin.addBaseLayer(mbTilesLayer, false);</span>
                }
            }
        }

<span class="fc" id="L98">    }</span>

    private void initializeMbTilesServer() {
        // Mapbox SDK only knows how to fetch tiles via HTTP.  If we want it to
        // display tiles from a local file, we have to serve them locally over HTTP.
        try {
<span class="fc" id="L104">            tileServer = new TileHttpServer();</span>
<span class="fc" id="L105">            tileServer.start();</span>
<span class="nc" id="L106">        } catch (IOException e) {</span>
<span class="nc" id="L107">            Timber.e(e, &quot;Could not start the TileHttpServer&quot;);</span>
<span class="fc" id="L108">        }</span>

<span class="fc" id="L110">    }</span>

    public void onDestroy() {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (tileServer != null) {</span>
<span class="fc" id="L114">            tileServer.destroy();</span>
        }
<span class="fc" id="L116">    }</span>

    private void addMbtiles(Style style, String id, File file) {
<span class="fc" id="L119">        Pair&lt;Source, List&lt;Layer&gt;&gt; sourceAndLayers = addMbtiles(id, file);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (sourceAndLayers != null) {</span>
<span class="fc" id="L121">            style.addSource(sourceAndLayers.first);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            for (Layer layer : sourceAndLayers.second)</span>
<span class="fc" id="L123">                style.addLayer(layer);</span>
        }
<span class="fc" id="L125">    }</span>

    private Pair&lt;Source, List&lt;Layer&gt;&gt; addMbtiles(String id, File file) {
        MbtilesFile mbtiles;
<span class="fc" id="L129">        List&lt;Layer&gt; mapLayers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L130">        Source source = null;</span>
        try {
<span class="fc" id="L132">            mbtiles = new MbtilesFile(file);</span>
<span class="nc" id="L133">        } catch (MbtilesFile.UnsupportedFormatException e) {</span>
<span class="nc" id="L134">            Timber.w(e, &quot;The mbtiles format is not known &quot;);</span>
<span class="nc" id="L135">            return null;</span>
<span class="fc" id="L136">        }</span>

<span class="fc" id="L138">        TileSet tileSet = createTileSet(mbtiles, tileServer.getUrlTemplate(id));</span>
<span class="fc" id="L139">        tileServer.addSource(id, mbtiles);</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (mbtiles.getType() == MbtilesFile.Type.VECTOR) {</span>
<span class="fc" id="L142">            source = new VectorSource(id, tileSet);</span>
<span class="fc" id="L143">            List&lt;MbtilesFile.VectorLayer&gt; layers = mbtiles.getVectorLayers();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            for (MbtilesFile.VectorLayer layer : layers) {</span>
                // Pick a colour that's a function of the filename and layer name.
<span class="fc" id="L146">                int hue = (((id + &quot;.&quot; + layer.name).hashCode()) &amp; 0x7fffffff) % 360;</span>
<span class="fc" id="L147">                mapLayers.add(new FillLayer(id + &quot;/&quot; + layer.name + &quot;.fill&quot;, id).withProperties(</span>
<span class="fc" id="L148">                        fillColor(Color.HSVToColor(new float[]{hue, 0.3f, 1})),</span>
<span class="fc" id="L149">                        fillOpacity(0.1f)</span>
<span class="fc" id="L150">                ).withSourceLayer(layer.name));</span>
<span class="fc" id="L151">                mapLayers.add(new LineLayer(id + &quot;/&quot; + layer.name + &quot;.line&quot;, id).withProperties(</span>
<span class="fc" id="L152">                        lineColor(Color.HSVToColor(new float[]{hue, 0.7f, 1})),</span>
<span class="fc" id="L153">                        lineWidth(1f),</span>
<span class="fc" id="L154">                        lineOpacity(0.7f)</span>
<span class="fc" id="L155">                ).withSourceLayer(layer.name));</span>
<span class="fc" id="L156">            }</span>
        }
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (mbtiles.getType() == MbtilesFile.Type.RASTER) {</span>
<span class="fc" id="L159">            source = new RasterSource(id, tileSet);</span>
<span class="fc" id="L160">            mapLayers.add(new RasterLayer(id + &quot;.raster&quot;, id).withProperties(</span>
<span class="fc" id="L161">                    rasterOpacity(0.5f)</span>
            ));
        }
<span class="fc" id="L164">        Timber.i(&quot;Added %s as a %s layer at /%s&quot;, file, mbtiles.getType(), id);</span>
<span class="fc" id="L165">        return new Pair&lt;&gt;(source, mapLayers);</span>
    }

    private TileSet createTileSet(MbtilesFile mbtiles, String urlTemplate) {
<span class="fc" id="L169">        TileSet tileSet = new TileSet(&quot;2.2.0&quot;, urlTemplate);</span>

        // Configure the TileSet using the metadata in the .mbtiles file.
<span class="fc" id="L172">        tileSet.setName(mbtiles.getMetadata(&quot;name&quot;));</span>
        try {
<span class="fc" id="L174">            tileSet.setMinZoom(Integer.parseInt(mbtiles.getMetadata(&quot;minzoom&quot;)));</span>
<span class="fc" id="L175">            tileSet.setMaxZoom(Integer.parseInt(mbtiles.getMetadata(&quot;maxzoom&quot;)));</span>
<span class="pc" id="L176">        } catch (NumberFormatException e) { /* ignore */ }</span>

<span class="fc" id="L178">        String[] parts = mbtiles.getMetadata(&quot;center&quot;).split(&quot;,&quot;);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (parts.length == 3) {  // latitude, longitude, zoom</span>
            try {
<span class="fc" id="L181">                tileSet.setCenter(</span>
<span class="fc" id="L182">                        Float.parseFloat(parts[0]), Float.parseFloat(parts[1]),</span>
<span class="fc" id="L183">                        (float) Integer.parseInt(parts[2])</span>
                );
<span class="pc" id="L185">            } catch (NumberFormatException e) { /* ignore */ }</span>
        }

<span class="fc" id="L188">        parts = mbtiles.getMetadata(&quot;bounds&quot;).split(&quot;,&quot;);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (parts.length == 4) {  // left, bottom, right, top</span>
            try {
<span class="fc" id="L191">                tileSet.setBounds(</span>
<span class="fc" id="L192">                        Float.parseFloat(parts[0]), Float.parseFloat(parts[1]),</span>
<span class="fc" id="L193">                        Float.parseFloat(parts[2]), Float.parseFloat(parts[3])</span>
                );
<span class="pc" id="L195">            } catch (NumberFormatException e) { /* ignore */ }</span>
        }

<span class="fc" id="L198">        return tileSet;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>