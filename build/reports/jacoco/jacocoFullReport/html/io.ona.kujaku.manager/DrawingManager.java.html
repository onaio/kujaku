<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DrawingManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kujaku</a> &gt; <a href="index.source.html" class="el_package">io.ona.kujaku.manager</a> &gt; <span class="el_source">DrawingManager.java</span></div><h1>DrawingManager.java</h1><pre class="source lang-java linenums">package io.ona.kujaku.manager;

import android.graphics.Color;
import android.graphics.PointF;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import com.mapbox.geojson.Feature;
import com.mapbox.geojson.FeatureCollection;
import com.mapbox.geojson.Geometry;
import com.mapbox.geojson.Point;
import com.mapbox.geojson.Polygon;
import com.mapbox.mapboxsdk.geometry.LatLng;
import com.mapbox.mapboxsdk.geometry.LatLngBounds;
import com.mapbox.mapboxsdk.maps.MapboxMap;
import com.mapbox.mapboxsdk.maps.Style;
import com.mapbox.mapboxsdk.plugins.annotation.Circle;
import com.mapbox.mapboxsdk.plugins.annotation.CircleManager;
import com.mapbox.mapboxsdk.plugins.annotation.FillManager;
import com.mapbox.mapboxsdk.plugins.annotation.FillOptions;
import com.mapbox.mapboxsdk.plugins.annotation.LineManager;
import com.mapbox.mapboxsdk.plugins.annotation.LineOptions;
import com.mapbox.mapboxsdk.plugins.annotation.OnCircleClickListener;
import com.mapbox.mapboxsdk.plugins.annotation.OnCircleDragListener;
import com.mapbox.mapboxsdk.style.expressions.Expression;

import java.util.ArrayList;
import java.util.List;

import io.ona.kujaku.layers.FillBoundaryLayer;
import io.ona.kujaku.layers.KujakuLayer;
import io.ona.kujaku.listeners.OnDrawingCircleClickListener;
import io.ona.kujaku.listeners.OnKujakuLayerLongClickListener;
import io.ona.kujaku.views.KujakuMapView;

/**
 * Manager use to draw polygons on Map.
 * Encapsulate a FillManager, LineManager and CircleManager
 *
 * Created by Emmanuel Otin - eo@novel-t.ch on 19/06/2019
 */
public class DrawingManager {

    private KujakuMapView kujakuMapView;
    private MapboxMap mapboxMap;
    private List&lt;KujakuCircle&gt; circles;
    private KujakuCircle currentKujakuCircle;

    private FillManager fillManager;
    private LineManager lineManager;
    private CircleManager circleManager;

    private OnDrawingCircleClickListener onDrawingCircleClickListener;
    private OnKujakuLayerLongClickListener onKujakuLayerLongClickListener;

    private boolean drawingEnabled;

    private FillBoundaryLayer currentFillBoundaryLayer;

    /**
     * Constructor
     *
     * @param mapView
     * @param mapboxMap
     * @param style
     */
<span class="fc" id="L67">    public DrawingManager(@NonNull KujakuMapView mapView, @NonNull MapboxMap mapboxMap, @NonNull Style style) {</span>
<span class="fc" id="L68">        this.kujakuMapView = mapView;</span>
<span class="fc" id="L69">        this.mapboxMap = mapboxMap;</span>

<span class="fc" id="L71">        this.circles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L72">        this.setCurrentKujakuCircle(null);</span>

<span class="fc" id="L74">        fillManager = AnnotationRepositoryManager.getFillManagerInstance(mapView, mapboxMap, style);</span>
<span class="fc" id="L75">        lineManager = AnnotationRepositoryManager.getLineManagerInstance(mapView, mapboxMap, style);</span>
<span class="fc" id="L76">        circleManager = AnnotationRepositoryManager.getCircleManagerInstance(mapView, mapboxMap, style);</span>

<span class="fc" id="L78">        circleManager.addClickListener(new OnCircleClickListener() {</span>
            @Override
            public void onAnnotationClick(Circle circle) {
<span class="nc bnc" id="L81" title="All 2 branches missed.">                if (drawingEnabled) {</span>
<span class="nc" id="L82">                    unsetCurrentCircleDraggable();</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">                    setDraggable(!circle.isDraggable(), circle);</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">                    if (onDrawingCircleClickListener != null) {</span>
<span class="nc" id="L86">                        onDrawingCircleClickListener.onCircleClick(circle);</span>
                    }
                }
<span class="nc" id="L89">            }</span>
        });

<span class="fc" id="L92">        circleManager.addDragListener(new OnCircleDragListener() {</span>
            @Override
            public void onAnnotationDragStarted(Circle circle) {
                // Left empty on purpose
<span class="nc" id="L96">            }</span>

            @Override
            public void onAnnotationDrag(Circle circle) {
<span class="nc" id="L100">                refreshPolygon();</span>
<span class="nc" id="L101">            }</span>

            @Override
            public void onAnnotationDragFinished(Circle circle) {
                // Left empty on purpose
<span class="nc" id="L106">            }</span>
        });

<span class="fc" id="L109">        mapboxMap.addOnMapClickListener(new MapboxMap.OnMapClickListener() {</span>
            @Override
            public boolean onMapClick(@NonNull LatLng point) {
<span class="nc" id="L112">                final PointF pixel = mapboxMap.getProjection().toScreenLocation(point);</span>
<span class="nc" id="L113">                List&lt;Feature&gt; features = mapboxMap.queryRenderedFeatures(pixel, (Expression) null, CircleManager.ID_GEOJSON_LAYER);</span>

<span class="nc bnc" id="L115" title="All 4 branches missed.">                if (features.size() == 0 &amp;&amp; drawingEnabled) {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">                    if (getCurrentKujakuCircle() != null) {</span>
<span class="nc" id="L117">                        unsetCurrentCircleDraggable();</span>
                    } else {
<span class="nc" id="L119">                        drawCircle(point);</span>
                    }

<span class="nc bnc" id="L122" title="All 2 branches missed.">                    if (onDrawingCircleClickListener != null) {</span>
<span class="nc" id="L123">                        onDrawingCircleClickListener.onCircleNotClick(point);</span>
                    }
                }

<span class="nc" id="L127">                return false;</span>
            }
        });

<span class="fc" id="L131">        kujakuMapView.setOnKujakuLayerLongClickListener(new OnKujakuLayerLongClickListener() {</span>
            @Override
            public void onKujakuLayerLongClick(@NonNull KujakuLayer kujakuLayer) {
<span class="nc bnc" id="L134" title="All 4 branches missed.">                if (!isDrawingEnabled() &amp;&amp; kujakuLayer instanceof FillBoundaryLayer) {</span>
<span class="nc" id="L135">                    startDrawing((FillBoundaryLayer)kujakuLayer);</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">                    if (onKujakuLayerLongClickListener != null) {</span>
<span class="nc" id="L138">                        onKujakuLayerLongClickListener.onKujakuLayerLongClick(kujakuLayer);</span>
                    }
                }
<span class="nc" id="L141">            }</span>
        });
<span class="fc" id="L143">    }</span>

    public static KujakuCircleOptions getKujakuCircleOptions(){
<span class="fc" id="L146">        return new KujakuCircleOptions()</span>
<span class="fc" id="L147">                .withCircleRadius(15.0f)</span>
<span class="fc" id="L148">                .withCircleColor(&quot;black&quot;)</span>
<span class="fc" id="L149">                .withMiddleCircle(false)</span>
<span class="fc" id="L150">                .withDraggable(false);</span>
    }

    public static KujakuCircleOptions getKujakuCircleMiddleOptions() {
<span class="fc" id="L154">        return new KujakuCircleOptions()</span>
<span class="fc" id="L155">                .withCircleRadius(10.0f)</span>
<span class="fc" id="L156">                .withCircleColor(&quot;black&quot;)</span>
<span class="fc" id="L157">                .withMiddleCircle(true)</span>
<span class="fc" id="L158">                .withDraggable(false);</span>
    }

    public static KujakuCircleOptions getKujakuCircleDraggableOptions() {
<span class="fc" id="L162">        return new KujakuCircleOptions()</span>
<span class="fc" id="L163">                .withCircleRadius(20.0f)</span>
<span class="fc" id="L164">                .withCircleColor(&quot;red&quot;)</span>
<span class="fc" id="L165">                .withMiddleCircle(false)</span>
<span class="fc" id="L166">                .withDraggable(true);</span>
    }

    /**
     * Drawing enabled/disabled
     *
     * @param drawing
     */
    private void setDrawing(boolean drawing) {
<span class="fc" id="L175">        this.drawingEnabled = drawing;</span>
<span class="fc" id="L176">    }</span>

    /**
     * Set currentCircle when circle is clicked or longClicked
     *
     * @param circle
     */
    private void setCurrentCircle(@Nullable Circle circle) {
<span class="fc" id="L184">        this.currentKujakuCircle = getKujakuCircle(circle);</span>
<span class="fc" id="L185">    }</span>

    /**
     * Set currentCircle when kujakuCircle is clicked or longClicked
     *
     * @param kujakuCircle
     */
    private void setCurrentKujakuCircle(@Nullable KujakuCircle kujakuCircle) {
<span class="fc" id="L193">        this.currentKujakuCircle = kujakuCircle;</span>
<span class="fc" id="L194">    }</span>

    /**
     * Start Drawing. A FillBoundaryLayer can be passed to init the drawing.
     *
     * @param fillBoundaryLayer
     * @return
     */
    public boolean startDrawing(@Nullable FillBoundaryLayer fillBoundaryLayer) {
<span class="fc" id="L203">        this.currentFillBoundaryLayer = fillBoundaryLayer;</span>

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (fillBoundaryLayer == null) {</span>
<span class="nc" id="L206">            this.startDrawingPoints(new ArrayList&lt;&gt;());</span>
<span class="nc" id="L207">            return true;</span>
        }

<span class="pc bpc" id="L210" title="2 of 4 branches missed.">        if (fillBoundaryLayer.getFeatureCollection().features() != null &amp;&amp; fillBoundaryLayer.getFeatureCollection().features().size() &gt;= 1) {</span>
<span class="fc" id="L211">            Geometry geometry = fillBoundaryLayer.getFeatureCollection().features().get(0).geometry();</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (geometry instanceof Polygon) {</span>
                // hide layer
<span class="fc" id="L214">                fillBoundaryLayer.disableLayerOnMap(mapboxMap);</span>

<span class="fc" id="L216">                Polygon polygon = (Polygon) geometry;</span>
<span class="fc" id="L217">                List&lt;Point&gt; points = polygon.coordinates().get(0);</span>
<span class="fc" id="L218">                this.startDrawingPoints(points);</span>
<span class="fc" id="L219">                return true;</span>
            }
        }

<span class="nc" id="L223">        return false;</span>
    }

    /**
     * Start Drawing. A list of point can be passed to init the drawing.
     *
     * @param points
     */
    public void startDrawingPoints(@Nullable List&lt;Point&gt; points) {
<span class="fc" id="L232">        setDrawing(true);</span>
<span class="fc" id="L233">        setCurrentCircle(null);</span>

<span class="pc bpc" id="L235" title="1 of 4 branches missed.">        if (points != null &amp;&amp; points.size() &gt; 0) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            for (Point p : points) {</span>
<span class="fc" id="L237">                this.create(getKujakuCircleOptions().withLatLng(new LatLng(p.latitude(), p.longitude())), false);</span>
<span class="fc" id="L238">            }</span>

<span class="fc" id="L240">            this.refresh(true);</span>
        }
<span class="fc" id="L242">    }</span>

    /**
     * Stop drawing and create a new FillBoundary layer or update the existing one
     *
     * @return
     */
    public Polygon stopDrawingAndDisplayLayer() {
<span class="fc" id="L250">        Polygon polygon = this.stopDrawing();</span>

<span class="fc" id="L252">        Feature feature = Feature.fromGeometry(polygon);</span>
<span class="fc" id="L253">        FeatureCollection collection = FeatureCollection.fromFeature(feature);</span>

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (this.currentFillBoundaryLayer != null) { // Update layer</span>
<span class="nc" id="L256">            this.currentFillBoundaryLayer.updateFeatures(collection);</span>
<span class="nc" id="L257">            this.currentFillBoundaryLayer.enableLayerOnMap(mapboxMap);</span>

        } else {                        // Create layer
<span class="fc" id="L260">            FillBoundaryLayer layer = new FillBoundaryLayer.Builder(collection)</span>
<span class="fc" id="L261">                    .setBoundaryColor(Color.BLACK)</span>
<span class="fc" id="L262">                    .setBoundaryWidth(3f)</span>
<span class="fc" id="L263">                    .build();</span>

<span class="fc" id="L265">            kujakuMapView.addLayer(layer);</span>
        }
<span class="fc" id="L267">        this.currentFillBoundaryLayer = null;</span>

<span class="fc" id="L269">        return polygon;</span>
    }

    /**
     * Stop drawing and return the drawn polygon
     *
     * @return
     */
    private Polygon stopDrawing() {
<span class="fc" id="L278">        setDrawing(false);</span>
<span class="fc" id="L279">        setCurrentCircle(null);</span>

        // convert into polygon
<span class="fc" id="L282">        List&lt;Point&gt; points = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L283">        List&lt;List&lt;Point&gt;&gt; lists = new ArrayList&lt;&gt;();</span>

        // Return only real points, not middles
<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (KujakuCircle c: this.circles) {</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (! c.isMiddleCircle()) {</span>
<span class="fc" id="L288">                points.add(c.getCircle().getGeometry());</span>
            }
<span class="fc" id="L290">        }</span>

<span class="fc" id="L292">        lists.add(points);</span>
        // Delete annotations
<span class="fc" id="L294">        this.deleteAll();</span>
        // Refresh
<span class="fc" id="L296">        this.refresh(false);</span>

<span class="fc" id="L298">        return Polygon.fromLngLats(lists);</span>
    }

    /**
     * Is Drawing enabled ?
     * @return
     */
    public boolean isDrawingEnabled() {
<span class="fc" id="L306">        return this.drawingEnabled;</span>
    }


    /**
     * Retrieve the KujakuCircle corresponding to the Circle
     *
     * @param circle
     * @return
     */
    private KujakuCircle getKujakuCircle(@Nullable Circle circle) {
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (circle == null) {</span>
<span class="fc" id="L318">            return null;</span>
        }

<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        for (KujakuCircle c : circles) {</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">            if (c.getCircle().getId() == circle.getId()) {</span>
<span class="fc" id="L323">                return c;</span>
            }
<span class="nc" id="L325">        }</span>

<span class="nc" id="L327">        return null;</span>
    }

    /**
     * Creation of middle points between 2 real points
     */
    private void createMiddlePoints() {
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (this.getKujakuCircles().size() &gt; 1) {</span>
<span class="fc" id="L335">            List&lt;KujakuCircleOptions&gt; newCirclesOptions = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L337">            List&lt;KujakuCircle&gt; circles = this.getKujakuCircles();</span>
<span class="fc" id="L338">            Circle circle1 = null;</span>
<span class="fc" id="L339">            Circle circle2 = null;</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">            for(int i = 0 ; i &lt; circles.size() ; i ++) {</span>
<span class="fc" id="L342">                KujakuCircle circle = circles.get(i);</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">                if (!circle.isMiddleCircle()) {</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                    if (circle1 == null) {</span>
<span class="fc" id="L346">                        circle1 = circle.getCircle();</span>
<span class="fc" id="L347">                        newCirclesOptions.add(getKujakuCircleOptions().withLatLng(circle1.getLatLng()));</span>
                    } else {
<span class="fc" id="L349">                        circle2 = circle.getCircle();</span>
                    }
                }

<span class="pc bpc" id="L353" title="1 of 4 branches missed.">                if (circle1 != null &amp;&amp; circle2 != null) {</span>
<span class="fc" id="L354">                    KujakuCircleOptions newKujakuCircleOptions = this.createMiddleKujakuCircleOptions(circle1, circle2, getKujakuCircleMiddleOptions()) ;</span>
<span class="fc" id="L355">                    newCirclesOptions.add(newKujakuCircleOptions);</span>
<span class="fc" id="L356">                    newCirclesOptions.add(getKujakuCircleOptions().withLatLng(circle2.getLatLng()));</span>

<span class="fc" id="L358">                    circle1 = circle2;</span>
<span class="fc" id="L359">                    circle2 = null;</span>
                }
            }

<span class="pc bpc" id="L363" title="1 of 2 branches missed.">            if (circle1 != null) {</span>
<span class="fc" id="L364">                circle2 = this.getKujakuCircles().get(0).getCircle();</span>

<span class="fc" id="L366">                KujakuCircleOptions newKujakuCircleOptions = this.createMiddleKujakuCircleOptions(circle1, circle2, getKujakuCircleMiddleOptions()) ;</span>
<span class="fc" id="L367">                newCirclesOptions.add(newKujakuCircleOptions);</span>
            }

<span class="fc" id="L370">            this.deleteAll();</span>
<span class="fc" id="L371">            this.createFromList(newCirclesOptions);</span>
        }
<span class="fc" id="L373">    }</span>

    /**
     * Create new KujakuCircleOptions between circle1 and circle2 lat long.
     *
     * @param circle1
     * @param circle2
     * @param options
     * @return
     */
    private KujakuCircleOptions createMiddleKujakuCircleOptions(@NonNull Circle circle1, @NonNull Circle circle2, @NonNull KujakuCircleOptions options) {
<span class="fc" id="L384">        double lonEast = Math.max(circle1.getLatLng().getLongitude(), circle2.getLatLng().getLongitude());</span>
<span class="fc" id="L385">        double lonWest = Math.min(circle1.getLatLng().getLongitude(), circle2.getLatLng().getLongitude());</span>
<span class="fc" id="L386">        double latNorth = Math.max(circle1.getLatLng().getLatitude(), circle2.getLatLng().getLatitude());</span>
<span class="fc" id="L387">        double latSouth = Math.min(circle1.getLatLng().getLatitude(), circle2.getLatLng().getLatitude());</span>

<span class="fc" id="L389">        LatLng latLng =</span>
<span class="fc" id="L390">                LatLngBounds.from(latNorth, lonEast, latSouth, lonWest).getCenter();</span>

<span class="fc" id="L392">        return options</span>
<span class="fc" id="L393">                .withLatLng(latLng);</span>
    }

    /**
     * Refresh the entire Polygon appearance
     *
     */
    private void refreshPolygon() {
<span class="fc" id="L401">        fillManager.deleteAll();</span>
<span class="fc" id="L402">        lineManager.deleteAll();</span>

<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (this.getKujakuCircles().size() &gt; 1) {</span>
<span class="fc" id="L405">            List&lt;LatLng&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">            for (int i = 0 ; i &lt; this.getKujakuCircles().size() ; i++) {</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                if (! this.getKujakuCircles().get(i).isMiddleCircle()) {</span>
<span class="fc" id="L408">                    list.add(this.getKujakuCircles().get(i).getCircle().getLatLng());</span>
                }
            }

<span class="fc" id="L412">            List&lt;List&lt;LatLng&gt;&gt; lists =  new ArrayList&lt;&gt;();</span>
<span class="fc" id="L413">            lists.add(list);</span>

<span class="fc" id="L415">            fillManager.create(new FillOptions()</span>
<span class="fc" id="L416">                    .withLatLngs(lists)</span>
<span class="fc" id="L417">                    .withFillOpacity(Float.valueOf(&quot;0.5&quot;)));</span>

            // We add the first point to the end of the list too
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (this.getKujakuCircles().size() &gt; 2) {</span>
<span class="fc" id="L421">                list.add(this.getKujakuCircles().get(0).getCircle().getLatLng());</span>
            }

<span class="fc" id="L424">            lineManager.create(new LineOptions()</span>
<span class="fc" id="L425">                    .withLatLngs(list)</span>
<span class="fc" id="L426">                    .withLineOpacity(Float.valueOf(&quot;0.5&quot;)));</span>
        }
<span class="fc" id="L428">    }</span>

    /**
     * Draw circle with kujakuCircleOptions
     *
     * @param latLng
     * @return
     */
    public Circle drawCircle(@NonNull LatLng latLng) {
<span class="nc" id="L437">        return this.create(DrawingManager.getKujakuCircleOptions().withLatLng(latLng));</span>
    }

    /***
     * Create a new Circle, add it to the circle list and refresh the polygon
     *
     * @param options
     * @return
     */
    public Circle create(@NonNull KujakuCircleOptions options) {
<span class="fc" id="L447">       return this.create(options, true);</span>
    }

    /**
     * Create a new Circle and add it to the circle list
     * Refresh the polygon depends of the refresh variable
     *
     * @param options
     * @param refresh
     * @return
     */
    private Circle create(@NonNull KujakuCircleOptions options, boolean refresh) {
<span class="fc" id="L459">        Circle circle = circleManager.create(options);</span>
<span class="fc" id="L460">        KujakuCircle previousCircle = null;</span>

<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (circles.size() &gt; 0) {</span>
<span class="fc" id="L463">            previousCircle = circles.get(circles.size() -1);</span>
        }

<span class="fc" id="L466">        KujakuCircle kujakuCircle = new KujakuCircle(circle, previousCircle, options.getMiddleCircle());</span>
<span class="fc" id="L467">        circles.add(kujakuCircle);</span>

<span class="fc bfc" id="L469" title="All 2 branches covered.">        if (refresh) {</span>
<span class="fc" id="L470">            this.refresh(true);</span>
        }

<span class="fc" id="L473">        return circle;</span>
    }

    /**
     * Create circles from list of KujakuCircleOptions
     *
     * @param options
     */
    private void createFromList(@NonNull List&lt;KujakuCircleOptions&gt; options) {
<span class="fc bfc" id="L482" title="All 2 branches covered.">        for (KujakuCircleOptions option: options) {</span>
<span class="fc" id="L483">            this.create(option, false);</span>
<span class="fc" id="L484">        }</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">        if (this.circles.size() &gt;= 2) {</span>
<span class="fc" id="L486">            this.getKujakuCircles().get(0).setPreviousKujakuCircle(this.getKujakuCircles().get(this.getKujakuCircles().size() - 1));</span>
        }

<span class="fc" id="L489">        this.refresh(false);</span>
<span class="fc" id="L490">    }</span>

    /**
     * Refresh the Polygon
     */
    private void refresh(boolean createMiddlePoints) {
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (createMiddlePoints) {</span>
<span class="fc" id="L497">            this.createMiddlePoints();</span>
        }
<span class="fc" id="L499">        this.refreshPolygon();</span>
<span class="fc" id="L500">    }</span>

    /**
     * Delete all
     */
    private void deleteAll() {
<span class="fc" id="L506">        this.circles.clear();</span>
<span class="fc" id="L507">        this.circleManager.deleteAll();</span>
<span class="fc" id="L508">        this.fillManager.deleteAll();</span>
<span class="fc" id="L509">        this.lineManager.deleteAll();</span>
<span class="fc" id="L510">    }</span>

    /**
     * Delete a Circle and the middles circles before and after
     *
     * @param kujakuCircle
     */
    public void delete(@Nullable KujakuCircle kujakuCircle) {
        // Previous and next circle to delete if AreMiddle
<span class="fc bfc" id="L519" title="All 2 branches covered.">        if (kujakuCircle == null) {</span>
<span class="fc" id="L520">            return ;</span>
        }

<span class="fc" id="L523">        KujakuCircle previousCircle = kujakuCircle.getPreviousKujakuCircle();</span>
<span class="fc" id="L524">        KujakuCircle nextCircle = kujakuCircle.getNextKujakuCircle();</span>

<span class="fc" id="L526">        circleManager.delete(kujakuCircle.getCircle());</span>
<span class="fc" id="L527">        this.circles.remove(kujakuCircle);</span>

<span class="pc bpc" id="L529" title="2 of 4 branches missed.">        if (previousCircle != null &amp;&amp; previousCircle.isMiddleCircle()) {</span>
<span class="fc" id="L530">            circleManager.delete(previousCircle.getCircle());</span>
<span class="fc" id="L531">            this.circles.remove(previousCircle);</span>
        }

<span class="pc bpc" id="L534" title="2 of 4 branches missed.">        if (nextCircle != null &amp;&amp; nextCircle.isMiddleCircle()) {</span>
<span class="fc" id="L535">            circleManager.delete(nextCircle.getCircle());</span>
<span class="fc" id="L536">            this.circles.remove(nextCircle);</span>
        }

<span class="fc" id="L539">        this.setCurrentCircle(null);</span>
<span class="fc" id="L540">        this.refresh(true);</span>
<span class="fc" id="L541">    }</span>

    /**
     * Delete the current selected circle
     */
    public void deleteDrawingCurrentCircle() {
<span class="nc" id="L547">        this.delete(this.getCurrentKujakuCircle());</span>
<span class="nc" id="L548">    }</span>
    /**
     * Set Circle draggable
     * Remove middle circles after &amp; before when a circle is draggable
     *
     * @param draggable
     * @param circle
     */
    public void setDraggable(boolean draggable, @NonNull Circle circle) {
<span class="fc" id="L557">        circle.setDraggable(draggable);</span>
        KujakuCircleOptions options;

<span class="fc bfc" id="L560" title="All 2 branches covered.">        if (draggable) {</span>
<span class="fc" id="L561">            options = getKujakuCircleDraggableOptions();</span>
<span class="fc" id="L562">            this.setCurrentCircle(circle);</span>
        } else {
<span class="fc" id="L564">            options = getKujakuCircleOptions();</span>
<span class="fc" id="L565">            this.setCurrentCircle(null);</span>
        }

<span class="fc" id="L568">        circle.setCircleColor(options.getCircleColor());</span>
<span class="fc" id="L569">        circle.setCircleRadius(options.getCircleRadius());</span>

<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (draggable) {</span>
<span class="fc" id="L572">            KujakuCircle previousCircle = null;</span>
<span class="fc" id="L573">            KujakuCircle nextCircle = null;</span>

<span class="pc bpc" id="L575" title="1 of 2 branches missed.">            for (KujakuCircle c : circles) {</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">                if (c.getCircle().getId() == circle.getId()) {</span>
<span class="fc" id="L577">                    this.setCurrentKujakuCircle(c);</span>
<span class="fc" id="L578">                    c.setMiddleCircle(options.getMiddleCircle());</span>
<span class="fc" id="L579">                    previousCircle = c.getPreviousKujakuCircle();</span>
<span class="fc" id="L580">                    nextCircle = c.getNextKujakuCircle();</span>
<span class="fc" id="L581">                    break;</span>
                }
<span class="nc" id="L583">            }</span>

<span class="pc bpc" id="L585" title="2 of 4 branches missed.">            if (previousCircle != null &amp;&amp; previousCircle.isMiddleCircle()) {</span>
<span class="fc" id="L586">                circleManager.delete(previousCircle.getCircle());</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">                if (previousCircle.getPreviousKujakuCircle() != null) {</span>
<span class="fc" id="L588">                    previousCircle.getPreviousKujakuCircle().setNextKujakuCircle(getCurrentKujakuCircle());</span>
                }
<span class="fc" id="L590">                this.circles.remove(previousCircle);</span>
            }

<span class="pc bpc" id="L593" title="2 of 4 branches missed.">            if (nextCircle != null &amp;&amp; nextCircle.isMiddleCircle()) {</span>
<span class="fc" id="L594">                circleManager.delete(nextCircle.getCircle());</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">                if (nextCircle.getNextKujakuCircle() != null) {</span>
<span class="fc" id="L596">                    nextCircle.getNextKujakuCircle().setPreviousKujakuCircle(getCurrentKujakuCircle());</span>
                }
<span class="fc" id="L598">                this.circles.remove(nextCircle);</span>
            }
        }

<span class="fc" id="L602">        circleManager.update(circle);</span>

<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (!draggable) {</span>
<span class="fc" id="L605">            this.refresh(true);</span>
        }
<span class="fc" id="L607">    }</span>

    /**
     * Unset the draggable property to the current selected circle
     */
    public void unsetCurrentCircleDraggable() {
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if(this.getCurrentKujakuCircle() != null) {</span>
<span class="nc" id="L614">            this.setDraggable(false, this.getCurrentKujakuCircle().getCircle());</span>
        }
<span class="nc" id="L616">    }</span>

    /**
     * Return true if the circle is a middle one
     *
     * @param circle
     * @return
     */
    public boolean isMiddleCircle(@NonNull Circle circle) {
<span class="nc bnc" id="L625" title="All 2 branches missed.">        for (KujakuCircle c : circles) {</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            if (c.getCircle().getId() == circle.getId()) {</span>
<span class="nc" id="L627">                return c.isMiddleCircle();</span>
            }
<span class="nc" id="L629">        }</span>

<span class="nc" id="L631">        return false;</span>
    }

    /**
     * Return a list of All KujakuCircles
     *
     * @return
     */
    public List&lt;KujakuCircle&gt; getKujakuCircles() {
<span class="fc" id="L640">        return this.circles;</span>
    }

    /**
     * Return the current selected KujakuCircle
     *
     * @return
     */
    public KujakuCircle getCurrentKujakuCircle() {
<span class="fc" id="L649">        return this.currentKujakuCircle;</span>
    }

    /**
     * Set a listener for OnDrawingCircleClickListener
     *
     * @param listener
     */
    public void addOnDrawingCircleClickListener(OnDrawingCircleClickListener listener) {
<span class="nc" id="L658">        this.onDrawingCircleClickListener = listener;</span>
<span class="nc" id="L659">    }</span>

    /**
     * Set a listener for the OnKujakuLayerLongClickListener
     *
     * @param listener
     */
    public void addOnKujakuLayerLongClickListener(OnKujakuLayerLongClickListener listener) {
<span class="nc" id="L667">        this.onKujakuLayerLongClickListener = listener;</span>
<span class="nc" id="L668">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>